package br.com.ecoffee.service.auth;

import java.util.ArrayList;
import java.util.Date;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import br.com.ecoffee.model.cliente.Cliente;
import br.com.ecoffee.model.usuario.Usuario;
import br.com.ecoffee.service.cliente.ClienteService;
import br.com.ecoffee.service.usuario.UsuarioService;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

@Service
public class JwtUserDetailsService implements UserDetailsService {

	private ClienteService clienteService;
	private UsuarioService usuarioService;
    private AuthenticationManager authenticationManager;
    
	public JwtUserDetailsService(ClienteService clienteService, UsuarioService usuarioService,
			AuthenticationManager authenticationManager) {
		this.clienteService = clienteService;
		this.usuarioService = usuarioService;
		this.authenticationManager = authenticationManager;
	}

	@Value("${forum.jwt.secret}")
	private String secret;
	
    public void authenticate(String username, String password) throws Exception {
        try {
            authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));
        } 
        catch (DisabledException e) {
            throw new Exception("USER_DISABLED", e);
        } 
        catch (BadCredentialsException e) {
            throw new Exception("INVALID_CREDENTIALS", e);
        }
    }	

	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
	    Optional<Cliente> clienteOptional = clienteService.buscarClientePeloEmail(username);

	    if (clienteOptional.isPresent()) {
	        Cliente cliente = clienteOptional.get();
	        return new User(cliente.getEmail(), cliente.getSenha(), new ArrayList<>());
	    } 
	    else {
	        Optional<Usuario> usuarioOptional = usuarioService.buscarPorNomeUsuario(username);
	        if (usuarioOptional.isEmpty()) {
	            throw new UsernameNotFoundException("User not found with username: " + username);
	        }

	        Usuario usuario = usuarioOptional.get();
	        return new User(usuario.getNomeUsuario(), usuario.getSenha(), new ArrayList<>());
	    }
	}

	public String generateJwtToken(String username) {
		return Jwts.builder().setSubject(username).setIssuedAt(new Date())
				.setExpiration(new Date(System.currentTimeMillis() + 86400000))
				.signWith(SignatureAlgorithm.HS512, secret).compact();
	}

	public boolean validateToken(String token, UserDetails userDetails) {
		final String username = extractUsername(token);
		return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
	}

	private boolean isTokenExpired(String token) {
		final Date expiration = extractExpiration(token);
		return expiration.before(new Date());
	}

	private Date extractExpiration(String token) {
		return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody().getExpiration();
	}

	private String extractUsername(String token) {
		return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody().getSubject();
	}
}
